import sys
from PyQt6.QtWidgets import *
from PyQt6.QtGui import *
from PyQt6.QtCore import *
from PyQt6 import uic
import datetime
import requests
import json
import time

from modules.data_manager import DataManager

class DevicesPage(QWidget):
    """장치 관리 페이지 위젯 클래스"""
    
    def __init__(self, parent=None):
        super().__init__(parent)
        
        # UI 로드
        uic.loadUi("ui/widgets/devices.ui", self)
        
        # 데이터 관리자 가져오기
        self.data_manager = DataManager.get_instance()
        
        # 컨베이어 상태 초기화
        self.conveyor_running = False
        self.conveyor_status_code = "idle"  # idle, running, paused, error, disconnected
        
        # 분류 박스 재고량 초기화
        self.inventory_counts = {
            "A": 0,  # 물건(비식품)
            "B": 0,  # 실온 식품
            "C": 0,  # 냉장 식품
            "error": 0  # 오류 건수
        }
        self.waiting_items = 0
        self.total_processed = 0
        
        # API 요청 재시도 설정
        self.api_retry_count = 2
        self.api_timeout = 3
        
        # 컨베이어 제어 버튼 연결
        self.btn_start_conveyor.clicked.connect(self.start_conveyor)
        self.btn_stop_conveyor.clicked.connect(self.stop_conveyor)
        self.btn_pause_conveyor.clicked.connect(self.pause_conveyor)
        
        # UI 업데이트 타이머 설정
        self.update_timer = QTimer(self)
        self.update_timer.timeout.connect(self.update_ui)
        self.update_timer.start(1000)  # 1초 간격으로 UI 업데이트
        
        # 데이터 변경 이벤트 연결
        self.data_manager.conveyor_status_changed.connect(self.update_conveyor_status)
        self.data_manager.notification_added.connect(self.on_notification)
        
        # 소켓 이벤트 핸들러 등록
        if hasattr(self.data_manager, 'register_event_handler'):
            self.data_manager.register_event_handler('event', self.handle_standardized_event)
        
        # 초기 상태 로그 추가
        self._add_log_message("장치 페이지 초기화 완료")
    
    def _send_control_command(self, action, button_name):
        """공통 컨베이어 제어 명령 전송 함수"""
        try:
            server_conn = self.data_manager._server_connection
            if not (server_conn and server_conn.is_connected):
                self._add_log_message(f"서버 연결이 되어있지 않아 {button_name} 명령을 보낼 수 없습니다.")
                return False
                
            retry_count = 0
            while retry_count <= self.api_retry_count:
                try:
                    response = requests.post(
                        f"{server_conn.api_base_url}/sort/control",
                        json={"action": action},
                        timeout=self.api_timeout
                    )
                    response.raise_for_status()
                    
                    # 로그 추가
                    self._add_log_message(f"분류기 {button_name} 명령을 전송했습니다.")
                    return True
                except requests.exceptions.RequestException as e:
                    retry_count += 1
                    if retry_count > self.api_retry_count:
                        raise e
                    # 재시도 로그 (마지막 시도가 아닌 경우에만)
                    self._add_log_message(f"분류기 {button_name} 명령 재시도 중... ({retry_count}/{self.api_retry_count})")
                    
        except Exception as e:
            # 오류 로그 추가
            self._add_log_message(f"분류기 {button_name} 오류: {str(e)}")
            return False
    
    def start_conveyor(self):
        """컨베이어 시작 명령 전송"""
        print("시작 버튼 클릭")
        try:
            # API 호출 실행
            server_conn = self.data_manager._server_connection
            if server_conn and server_conn.is_connected:
                response = requests.post(
                    f"{server_conn.api_base_url}/sort/control",
                    json={"action": "start"},
                    timeout=self.api_timeout
                )
                
                # 성공 시 상태 업데이트
                self.conveyor_status_code = "running"
                self.update_conveyor_ui()
                self._add_log_message("분류기 시작 명령을 전송했습니다.")
            else:
                self._add_log_message("서버 연결이 되어있지 않아 시작 명령을 보낼 수 없습니다.")
        except Exception as e:
            self._add_log_message(f"시작 명령 오류: {str(e)}")
    
    def stop_conveyor(self):
        """컨베이어 정지 명령 전송"""
        print("정지 버튼 클릭")
        try:
            # API 호출 실행
            server_conn = self.data_manager._server_connection
            if server_conn and server_conn.is_connected:
                response = requests.post(
                    f"{server_conn.api_base_url}/sort/control",
                    json={"action": "stop"},
                    timeout=self.api_timeout
                )
                
                # 성공 시 상태 업데이트
                self.conveyor_status_code = "idle"
                self.update_conveyor_ui()
                self._add_log_message("분류기 정지 명령을 전송했습니다.")
            else:
                self._add_log_message("서버 연결이 되어있지 않아 정지 명령을 보낼 수 없습니다.")
        except Exception as e:
            self._add_log_message(f"정지 명령 오류: {str(e)}")
    
    def pause_conveyor(self):
        """컨베이어 일시정지 명령 전송"""
        print("일시정지 버튼 클릭")
        try:
            # API 호출 실행
            server_conn = self.data_manager._server_connection
            if server_conn and server_conn.is_connected:
                response = requests.post(
                    f"{server_conn.api_base_url}/sort/control",
                    json={"action": "pause"},
                    timeout=self.api_timeout
                )
                
                # 성공 시 상태 업데이트
                self.conveyor_status_code = "paused"
                self.update_conveyor_ui()
                self._add_log_message("분류기 일시정지 명령을 전송했습니다.")
            else:
                self._add_log_message("서버 연결이 되어있지 않아 일시정지 명령을 보낼 수 없습니다.")
        except Exception as e:
            self._add_log_message(f"일시정지 명령 오류: {str(e)}")
    
    def update_conveyor_status(self):
        """컨베이어 상태 업데이트"""
        conveyor_status = self.data_manager.get_conveyor_status()
        
        if conveyor_status == 1:  # 가동중
            self.conveyor_status_code = "running"
        elif conveyor_status == 2:  # 일시정지
            self.conveyor_status_code = "paused"
        else:  # 정지
            self.conveyor_status_code = "idle"
            
        self.update_conveyor_ui()
    
    def update_conveyor_ui(self):
        """컨베이어 상태에 따른 UI 업데이트"""
        print(f"UI 업데이트: 상태 = {self.conveyor_status_code}")
        
        if self.conveyor_status_code == "running":
            self.conveyor_status.setText("작동중")
            self.conveyor_status.setStyleSheet("background-color: #4CAF50; color: white; border-radius: 3px; padding: 2px;")
            self.conveyor_running = True
            # 시작 버튼 비활성화, 정지/일시정지 버튼 활성화
            self.btn_start_conveyor.setEnabled(False)
            self.btn_stop_conveyor.setEnabled(True)
            self.btn_pause_conveyor.setEnabled(True)
        elif self.conveyor_status_code == "paused":
            self.conveyor_status.setText("일시정지")
            self.conveyor_status.setStyleSheet("background-color: #FFC107; color: black; border-radius: 3px; padding: 2px;")
            self.conveyor_running = False
            # 시작 버튼 활성화, 일시정지 버튼 비활성화, 정지 버튼 활성화
            self.btn_start_conveyor.setEnabled(True)
            self.btn_stop_conveyor.setEnabled(True)
            self.btn_pause_conveyor.setEnabled(False)
        elif self.conveyor_status_code == "idle":
            self.conveyor_status.setText("정지")
            self.conveyor_status.setStyleSheet("background-color: #757575; color: white; border-radius: 3px; padding: 2px;")
            self.conveyor_running = False
            # 시작 버튼 활성화, 나머지 비활성화
            self.btn_start_conveyor.setEnabled(True)
            self.btn_stop_conveyor.setEnabled(False)
            self.btn_pause_conveyor.setEnabled(False)
        elif self.conveyor_status_code == "error":
            self.conveyor_status.setText("오류")
            self.conveyor_status.setStyleSheet("background-color: #F44336; color: white; border-radius: 3px; padding: 2px;")
            self.conveyor_running = False
            # 모든 버튼 비활성화
            self.btn_start_conveyor.setEnabled(False)
            self.btn_stop_conveyor.setEnabled(False)
            self.btn_pause_conveyor.setEnabled(False)
        else:  # disconnected
            self.conveyor_status.setText("연결 안됨")
            self.conveyor_status.setStyleSheet("background-color: #757575; color: white; border-radius: 3px; padding: 2px;")
            self.conveyor_running = False
            # 모든 버튼 비활성화
            self.btn_start_conveyor.setEnabled(False)
            self.btn_stop_conveyor.setEnabled(False)
            self.btn_pause_conveyor.setEnabled(False)
    
    def _add_log_message(self, message, highlight=False):
        """로그 메시지 추가 (중복 코드 제거용)"""
        current_time = QDateTime.currentDateTime().toString("hh:mm:ss")
        log_message = f"{current_time} - {message}"
        
        # 로그 목록에 추가
        item = QListWidgetItem(log_message)
        if highlight:
            item.setForeground(QColor("#F44336"))  # 강조 표시가 필요한 메시지는 빨간색으로
            font = item.font()
            font.setBold(True)
            item.setFont(font)
        
        self.list_logs.insertItem(0, item)
        
        # 최대 50개 로그만 유지
        if self.list_logs.count() > 50:
            self.list_logs.takeItem(self.list_logs.count() - 1)
    
    def on_notification(self, message):
        """알림 발생 시 처리"""
        # 컨베이어 관련 알림인 경우 로그에 추가
        if "컨베이어" in message or "벨트" in message or "인식" in message or "분류" in message:
            self._add_log_message(message)
    
    def handle_standardized_event(self, data):
        """표준화된 이벤트 처리"""
        try:
            # 문자열로 전달된 경우 JSON 파싱
            if isinstance(data, str):
                event_data = json.loads(data)
            else:
                event_data = data
                
            # 이벤트 데이터 추출
            event_type = event_data.get("type")
            category = event_data.get("category")
            action = event_data.get("action")
            payload = event_data.get("payload", {})
            
            # 분류기 관련 이벤트만 처리
            if category != "sorter":
                return
                
            # 이벤트 종류에 따른 처리
            if action == "status_update":
                self._handle_status_update(payload)
            elif action == "barcode_scanned":
                self._handle_barcode_scanned(payload)
            elif action == "error":
                self._handle_error_event(payload)
                
        except Exception as e:
            print(f"이벤트 처리 오류: {str(e)}")
    
    def _handle_status_update(self, payload):
        """상태 업데이트 이벤트 처리"""
        # 작동 상태 업데이트
        is_running = payload.get("is_running", False)
        self.conveyor_running = is_running
        self.conveyor_status_code = "running" if is_running else "idle"
        
        # 대기 물품 및 처리 물품 업데이트
        self.waiting_items = payload.get("items_waiting", 0)
        self.total_processed = payload.get("items_processed", 0)
        
        # 분류 카운트 업데이트
        sort_counts = payload.get("sort_counts", {})
        if sort_counts:
            self.inventory_counts.update(sort_counts)
            
            # UI 라벨도 직접 업데이트
            if "A" in sort_counts:
                self.inventory_A.setText(f"{sort_counts['A']}개")
            if "B" in sort_counts:
                self.inventory_B.setText(f"{sort_counts['B']}개")
            if "C" in sort_counts:
                self.inventory_C.setText(f"{sort_counts['C']}개")
            if "E" in sort_counts:
                self.inventory_error.setText(f"{sort_counts['E']}개")
                
                # 오류는 항상 빨간색
                if sort_counts['E'] > 0:
                    self.inventory_error.setStyleSheet("color: #F44336; font-weight: bold;")
                else:
                    self.inventory_error.setStyleSheet("color: #757575;")
        
        # 대기/처리 아이템 UI 업데이트
        self.inventory_waiting.setText(f"{self.waiting_items}개")
        self.inventory_waiting_2.setText(f"{self.total_processed}개")
        
        # UI 업데이트
        self.update_conveyor_ui()
    
    def _handle_barcode_scanned(self, payload):
        """바코드 스캔 이벤트 처리"""
        barcode = payload.get("barcode", "")
        category = payload.get("category", "")
        timestamp = payload.get("timestamp", 0)
        
        # 타임스탬프 변환
        if isinstance(timestamp, (int, float)):
            dt = QDateTime.fromSecsSinceEpoch(int(timestamp))
            timestamp_str = dt.toString("hh:mm:ss")
        else:
            timestamp_str = QDateTime.currentDateTime().toString("hh:mm:ss")
        
        # 로그 메시지 생성
        if barcode:
            if category in ["A", "B", "C"]:
                log_message = f"QR {barcode} 인식됨, 창고 {category}(으)로 분류"
            else:
                log_message = f"QR {barcode} 인식 실패, 분류 오류"
                
            # 로그 추가
            self._add_log_message(log_message)
    
    def _handle_error_event(self, payload):
        """오류 이벤트 처리"""
        error_code = payload.get("error_code", "unknown")
        error_message = payload.get("error_message", "알 수 없는 오류")
        
        # 로그 추가 (강조 표시)
        log_message = f"오류 발생: {error_message} (코드: {error_code})"
        self._add_log_message(log_message, True)
        
        # 대기 물품이 있는 경우 일시정지 상태로, 없는 경우 정지 상태로 설정
        if self.waiting_items > 0:
            self.conveyor_status_code = "paused"
            self._add_log_message("대기 물품이 있어 일시정지 상태로 전환합니다.")
        else:
            self.conveyor_status_code = "idle"
            self._add_log_message("대기 물품이 없어 정지 상태로 전환합니다.")
            
        self.update_conveyor_ui()
    
    def update_ui(self):
        """UI 요소 업데이트"""
        try:
            # 서버 연결 객체 가져오기
            server_conn = self.data_manager._server_connection
            
            if server_conn and server_conn.is_connected:
                # 5초마다 서버에서 최신 데이터 가져오기
                if int(time.time()) % 5 == 0:
                    self.request_status_update()
            else:
                # 연결이 끊어진 경우 UI 업데이트
                if self.conveyor_status_code != "disconnected":
                    self.conveyor_status_code = "disconnected"
                    self.update_conveyor_ui()
        
        except Exception as e:
            print(f"UI 업데이트 중 오류: {str(e)}")
    
    def onConnectionStatusChanged(self, connected):
        """서버 연결 상태 변경 시 호출되는 메서드"""
        if connected:
            # 연결 성공 시 처리
            self._add_log_message("서버에 연결되었습니다.")
            
            # 상태 갱신 요청
            self.request_status_update()
        else:
            # 연결 실패 시 처리
            self._add_log_message("서버 연결이 끊어졌습니다.", True)
            
            # 연결이 끊어지면 컨베이어는 연결 안됨 상태로 표시
            self.conveyor_status_code = "disconnected"
            self.update_conveyor_ui()
    
    def request_status_update(self):
        """서버에 상태 업데이트 요청"""
        try:
            server_conn = self.data_manager._server_connection
            if not (server_conn and server_conn.is_connected):
                return
                
            response = requests.get(
                f"{server_conn.api_base_url}/sort/status",
                timeout=self.api_timeout
            )
            response.raise_for_status()
            
            # 응답 데이터 처리
            status_data = response.json()
            if "status" in status_data:
                status = status_data["status"]
                self.conveyor_running = status.get("state") == "running"
                self.conveyor_status_code = "running" if self.conveyor_running else "idle"
                
                self.waiting_items = status.get("items_waiting", 0)
                self.total_processed = status.get("items_processed", 0)
                
                # 분류 카운트 업데이트
                sort_counts = status.get("sort_counts", {})
                if sort_counts:
                    self.inventory_counts.update(sort_counts)
                
                # UI 업데이트
                self.update_conveyor_ui()
                
                # 로그 업데이트
                if status_data.get("logs"):
                    for log in status_data["logs"]:
                        barcode = log.get("barcode", "")
                        category = log.get("category", "")
                        if barcode and category:
                            self._handle_barcode_scanned(log)
            
        except Exception as e:
            print(f"상태 업데이트 요청 오류: {str(e)}")